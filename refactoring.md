# 重构

## 1.示例

差劲的系统是很难修改的，因为很难找到修改点

需求的变化使重构变得必要

### 步骤

保证即将修改的代码拥有一组可靠的测试

> 在数字时代，软件的名字就是脆弱

尽管编写测试需要花费时间，但却省下可观的调试时间

做完一次修改就运行测试，小步修改

使用版本控制器辅助重构



#### 提炼函数

##### 变量改名，函数参数改名

变量命名是代码清晰的关键

##### 以查询取代临时变量



对结构良好的代码进行性能调优要容易得多，程序员对代码的运行路径通常所知不足



#### 拆分阶段

分离数据和渲染

尽量保持数据不可变

以管道取代循环

分离文件



> 可演化的代码以明确为贵，而非精简

>  完美的境界很难到达，但应该勤加拂拭



#### 类型多态

分支逻辑很容易随代码堆积而腐坏

以多态取代条件表达式

如果构造函数无法返回子类，可以用工厂函数取代



大多数修改都涉及特定类型的计算

返回的结果应该根据数据的消费者来决定



### 总结

重构早期的主要动力是尝试理解代码如何工作

好代码的检验标砖就是人们是否能轻而易举地修改它，好代码应该直截了当

保持代码永远处于可工作状态



## 2. 重构的原则

### 2.1 定义

不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本

### 2.2 原因

#### 改进软件的设计

软件的内部设计（架构）会逐渐腐败变质

经常性的重构有助于代码维持自己该有的形态



改进设计的一个重要方向就是消除重复代码

代码越多，做正确的修改就越困难，因为有更多代码需要理解

消除重复代码，确定所有的事物和行为在代码中只表述一次，这正是优秀设计的根本

#### 使软件更容易理解

> 编程的核心就在于“准确说出我想要的”

> 不要刻意去记忆任何能够立即查阅的东西

#### 帮助找到bug

#### 提高编程速度

预先做出良好的设计非常困难

将代码库逐渐演化成一个平台



### 2.3 时机

> 三次法则: 事不过三，三则重构

#### 预备性重构

让添加新功能更容易

#### 帮助理解的重构

通过重构，把对代码的理解转移到代码本身

当代码变得清晰时，将更容易看到设计问题

#### 捡垃圾式重构

营地法则：至少要让营地比你到达时更干净

#### 有计划的重构和见机行事的重构

在添加功能和修改bug的同时顺便重构是自然编程流的一部分

重构不是与编程割裂的行为

整洁的代码也需要重构，但重构起来会更容易



有计划的重构应该很少



#### 长期重构

如库的替换，处理依赖关系，整块代码组件化



如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口（branch by abstraction）



#### 复审代码时重构

复审可以传播知识和提供建议

重构可以帮助复审别人的代码，还可以帮助代码复审工作得到更具体的结果

结对编程



#### 管理人员

如果管理人员不理解代码库的健康对生产率的影响就不要告诉他们



#### 何时不应该重构

- 不需要修改的代码
- 隐藏在api之下切不需要理解其工作原理的丑陋代码
- 重写比重构容易的代码
  - 需要良好的判断力和丰富的经验

### 2.4 挑战

#### 延缓新功能开发

”重构会拖慢进度“这种看法仍然很普遍

重构不足的情况远多于重构过度的情况



> 很多人没有太多在健康的代码库上工作的经历--轻松地把现有代码组合配置，快速构造出复杂的新功能，这种强大的开发方式他们没有体验过



重构应该总是由经济利益驱动



#### 代码所有权

代码所有权的边界会妨碍重构

- 使用不推荐使用（deprecated）标记接口

不要搞细粒度的强代码所有制（即一人分管一块代码），推荐团队代码所有制



跨团队的场合应该鼓励类似于开源的模型



#### 分支

在隔离的分支上工作的越久，将完成的工作集成回主线就会越困难

最困难的部分是处理语义变化

> 比如Alice在功能分支使用了Bob编写的函数，而Bob在另一个分支修改了函数名



- 尽量缩短特性分支的生存周期
- 采用持续集成（CI）
  - 保证主线随时处于健康状态
  - 将大功能拆分为小块
  - 使用特性开关（feature toggle），特性旗帜（feature flag）<https://zh.wikipedia.org/wiki/特性切换>



CI与重构能良好配合

如果特性分支存在的时间足够短，他们就不会造成大问题。但对全职开发团队而言，特性分支对重构的阻碍太严重了。



#### 测试

快速发现错误非常关键

需要完备的测试套件并且运行速度要快

团队必须投入时间与精力在测试上，但收益是绝对划算的



缺少测试可以使用自动化重构，但好用的重构手法不多



自测试代码与持续集成紧密相关



#### 遗留代码

只有在设计系统时就考虑测试才容易添加测试

> 《修改代码的艺术》

运用重构的手法创造接缝，在接缝处插入测试，但是非常困难

不建议尝试一鼓作气把复杂而混乱的遗留代码重构成漂亮的代码



#### 数据库

使用渐进式数据库设计和数据库重构的办法



使用小段代码来执行数据转换逻辑，并把这段代码放进版本控制，跟数据结构声明与使用代码的修改一并提交。

可以用于管道式迁移



##### 并行修改/扩展协议

数据库的重构最好是分散到多次生产发布来完成，知道生产环境稳定再删除没人使用的旧字段



### 2.5 重构与架构

重构可以改善既有代码的设计



应对未来变化的办法之一就是在软件里植入灵活性机制，但是很多时候这种灵活性机制反而拖慢了相应变化的速度

只根据当前的需求来构造软件，同时把软件的设计质量做的很高时更好的实践

如果一种灵活性会增加软件的复杂度，就必须先证明自己值得被引入

只有当未来重构会很困难时，才考虑现在就增加灵活性机制



把简单设计/增量式设计/YAGNI是为将架构、设计与开发过程融合的一种工作方式。

演进式架构是一门仍在不断发展的学科



### 2.6 重构与软件开发过程

重构起初是作为极限编程的一部分被人们采用的

实际上大部门“敏捷”项目只是徒有其名

重构的第一块基石是自测试代码



自测试代码、持续集成、重构 -- 彼此之间有着很强的协同效应

有这三大核心实践打下的基础，才谈得上运用敏捷思想的其他部分



> 软件开发是一件复杂而微妙的事，涉及人与人之间、人与机器之间的复杂交互



### 2.7 重构与性能

除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是：先写出可调优的软件，然后调优它以求获得足够的速度



编写快速软件的方法：

- 时间预算法
  - 分解设计时就做好预算，包括时间和空间占用
  - 性能要求极高的实时系统
    - 心律调节器程序
  - 迟来的数据就是错误的数据
- 持续关注法
  - 通常不起作用
  - 视角狭隘
  - 90%的优化工作都是白费劲，因为被优化的代码大多很少被执行
- 利用统计数据
  - 使用度量工具找出性能热点

构造良好的的程序有利于优化工作

- 节省修改所需时间
- 可以进行小粒度的性能分析



> 重构一次被滥用，很多是不严谨的结构调整



### 2.8 自动化重构

粗糙的自动化重构方式是文本操作，而精准的重构必须操作代码的语法树

静态类型有利于重构

即使是最安全的重构，也应该经常运行测试套件



> Language Server Protocol : 用软件生成语法树，给文本编辑器提供API



## 3. 代码的坏味道

在重构的精准衡量标准方面，没有任何度量规矩比得上见识广博者的直觉。



### 3.1 神秘命名

命名是编程中最难的两件事之一

如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题



### 3.2 重复代码

提炼函数



### 3.3 过长函数

活得最长、最好的程序，其中的函数都比较短

间接性带来的好处--更好的诠释力、更易于分享、更多的选择--都是由小函数来支持的

> 现代编程语言几乎已经完全免除了进程内的函数调用开销



积极的分解函数：每当感觉需要以注释来说明代码的时候，就应该抽离函数，并以其用途（而非实现手法）命名

处理好函数“做什么”和“如何做”之间的语义距离



- 提取函数
- 以查询取代临时变量
- 引入参数对象和保持对象完整
- 以命令取代函数
- 分解条件表达式
- 以多态取代条件表达式
- 拆分循环



### 3.4 过长参数列表

- 以查询取代参数
- 保持对象完整
- 引入参数对象
- 移除标记参数
- 使用类
  - 函数组合成类
    - 共有参数变成类的成员变量



### 3.5 全局变量

类变量和单例也可能存在全局变量问题

- 使用函数包装
- 迁移到类

全局变量适合不可变配置文件

> 良药与毒药的区别在于剂量



### 3.6 可变数据

封装变量：

- 拆分变量
- 将没有副作用的代码与执行数据更新操作的代码分开
  - API将查询函数和修改函数分离
- 尽早移除设置函数
- 以查询取代派生变量
  - 唯一性保障
- 引用对象改为值对象



### 3.7 发散式变化

每次只关心一个上下文这一点一直很重要

拆分阶段



### 3.8 霰弹式修改

内联



### 3.9 依恋情结

所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互



> 策略模式和访问者模式除外

将总是变化的东西放在一块



### 3.10 数据泥团

总是捆绑在一起的数据应该拥有属于它们自己的对象

参数列表缩短，简化函数调用

当有用的类被创建出来，大量的重复被消除



### 3.11 基本类型偏执

创造问题域有用的基本类型



字符串是这种坏味道的最佳培养皿

一个体面的类型，至少能包括一致的显示逻辑

注意“类字符串类型”变量

- 以对象取代基本类型
- 以子类取代类型码
  - 以多态取代条件表达式
- 提炼类



### 3.12 重复的switch

多态



### 3.13 循环语句

以管道取代循环



### 3.14 冗赘的元素

内联，折叠继承体系



### 3.15 夸夸其谈通用性

如果用不到，就不值得



### 3.16 临时字段

提炼类分离临时字段，或者引入特例



### 3.17 过长的消息链

隐藏委托关系

观察消息链最终得到的对象的作用，将使用对象的代码提炼到函数中并将函数推入消息链



### 3.18 中间人

不要过度运用委托



### 3.19 内幕交易（Insider Trading）

子类对超类的了解总是超过后者的主观愿望



### 3.20 过大的类

### 3.21 异曲同工的类

### 3.22 纯数据类

纯数据类往往意味着行为被放在错误的地方，应该把处理数据的行为从客户端迁移到纯数据类里

中转数据除外，因为其不可修改

### 3.23 Refused Bequest

继承体系设计错误

当子类复用了超类的行为（实现）却又不愿意支持超类的接口时，使用委托取代继承



### 3.24 注释

很多注释之所以存在是因为代码很槽糕



自说明代码

引入断言说明系统需求规格



## 4. 构筑测试体系

### 4.1 自测试代码的价值

编写代码花费的时间所占很少，花费在调试的时间是最多的



> 类应该包含它们自己的测试代码 -- 1992年 OOPLSLA大会



频繁的自动化运行测试能够拥有强大的bug侦测能力



撰写测试代码最好时机是在开始动手编码之前，关注接口而非实现



TDD: 先编写一个（失败的）测试，编写代码使测试通过，然后进行重构以保证代码整洁



### 4.2 示例

> 隔离的思路在任何场景都适用



### 4.3 测试

测试的描述性的句子和注释一样，不外乎是重复代码已经表达的东西，只能能定位到失败的测试即可

测试集合中还有失败的测试时就不应该先去重构



观察被测试类应该做的所有事情，然后对这个类的每个行为进行测试，包括各种可能使它发生异常的边界条件



不同于测试所有public函数的风格，测试应该是风险驱动的行为，重点应该是最担心出错的部分



为既有代码添加测试的方法：先随便填一个期望值，再用程序生成的真实值来替换它，然后引入一个错误，最后恢复错误



共享测试夹具会使测试间产生交互，这是滋生bug的温床，使用beforeEach等钩子来使用独立的测试夹具，除非百分之百不可变



### 4.4 测试夹具

一个it语句中最好只有一个验证语句，不然前面的验证失败会掩盖重要信息



### 4.5 边界条件

空集合，数字0，空字符串，越界

编写边界测试能帮助思考代码本应如何应对边界场景



*是否采用防御式编程？*

可信数据源

在同一代码库的不同模块之间加入太多的检查往往会导致重复的验证代码，它带来的好处通常抵不过坏处，尤其是你添加的验证可能在其他地方早已做过

对于外部数据，如返回JSON数据的请求，就有必要验证了



使用断言避免脏数据到处传递



增加测试的边际效用会递减，把测试集中在可能出错的地方



### 4.6 重构之外的测试

测试即是重构的基础保障，本身也是一个有价值的工具

**一个架构的好坏，很大程度要取决于它的可测试性**



单元测试是自测试代码的支柱

测试也是一种迭代式活动，很难第一次就把测试写对

每当你遇到一个bug,先写一个测试来清楚的复现它



测试覆盖率不能用来衡量一个测试集的质量高低，测试集的质量衡量标准比较主观



测试也可能过犹不及：当改测试比改代码花费时间更多时



## 5. 重构名录

小步前进，情况越复杂，步子就越小

数个重构经常被一并运用

反向重构通常没太大意义



## 6. 第一组重构

形成函数并给函数命名，这是低层级重构的精髓

有了函数以后，就需要把它们组合成更高层级的模块（类）



### 6.1 提炼函数

将意图与实现分开

短函数常常能让编译器的优化功能运转更良好，因为短函数可以更容易被缓存

不用过早担心性能问题

必须在命名上花心思



如果发现源函数的参数被赋值,应该马上使用拆分变量，将其变成临时变量



多值返回: 构造并返回一个记录对象或者重新处理局部变量



最好将目标函数放在源函数的同级以检查提炼范围的合理性



### 6.2 内联函数

如果函数的内容和其名称同样清晰就可以考虑内联以减少非必要的间接性

如果有一群组织不合理的函数也可以先内联再提炼小函数

小步前进



### 6.3 提炼变量

表达式可能非常复杂而难以阅读，局部变量可以帮助我们将表达式分解为比较容易管理的形式。

变量使调试和打印语句变得方便



考虑变量的上下文，如果在更宽的上下有意义，考虑以函数形式暴露



对象：提供了合适的上下文，方便分享相关的逻辑和数据



### 6.4 内联变量

当名字并不比表达式本身更具表现力



### 6.5 改变函数声明

函数声明是软件系统的关节，系统的好坏很大程度上取决于关节

最重要的元素当属函数的名字：先写一句注释描述这个函数的用途，再把这句注释变成函数的名字



函数参数列表阐述了函数如何与外部世界共处

修改参数列表不仅能增加函数的应用范围，还能改变连接一个模块所需的条件，从而去除不必要的耦合

减少模块彼此之间的信息依赖，提高函数的封装度



#### 迁移式修改函数

先创建一个新的临时函数并实现

旧函数内联新的函数

调用方替换调用临时函数

删除旧函数

将临时函数命名为旧函数



##### 迁移式重构多态函数

- 继承体系中 ，在超类上转发
- 没有共同超类 ，在每个实现类上转发



#### 函数改名

静态类型加上趁手的IDE能提供最好的体验，通常可以全自动地完成函数改名

增减参数：找到所有的调用者，修改函数声明，然后修改的调用者



#### 添加参数

可以使用断言检查参数

自动化重构工具减少了迁移式做法的用武之地(改名，参数变更)，同时也使迁移式做法更加高效



### 6.6 封装变量

以函数的形式封装对数据的访问，将重新组织数据的任务转化为重新组织函数

封装能提供一个观测点，由此监控数据的变化和使用情况，轻松地添加数据被修改时的验证或后续逻辑

对于所有可变的数据，只要它的作用域超出单个函数，就将其封装起来，只允许通过函数访问

数据的作用域越大，封装就越重要

强调对象的数据应该保持私有，但自封装就有点儿过度了

不可变数据比封装数据更重要，不可变性是强大的代码防腐剂



封装变量名过程中可以取有意义又难看的临时使用变量名



#### 封装值

返回数据副本或使用封装记录（getter, setter）

复制对性能的影响通常可以忽略不计



### 6.7 变量改名

好的命名是整洁编程的核心

#### 常量改名

先声明新的常量名，然后把新常量复制给旧的名字，最后删除旧的名字



### 6.8 引入参数对象

催生代码中更深层次的改变

创造出函数捕捉围绕数据的共用行为，可能是一组共用函数，或者用一类把数据结构与使用数据的函数组合起来，提升为新的抽象概念，可以更好的理解问题域



### 6.9 函数组合成类

类，在大多数现代编程语言中都是基本的构造



如果发现一组函数形影不离地操作同一块数据，就可以考虑组建类以简化函数调用，客户端可以修改对象的核心数据，通过计算得出的派生数据则会自动与核心数据保持一致

也可以组合成嵌套函数，但测试困难



函数式语言：函数作为对象



>  统一访问原则: 客户代码不应由属性是通过字段实现还是方法实现而受影响



### 6.10 函数组合成变换

将派生数据以字段形式填入输出数据（增强enrich/变换transform）

如果代码中会对源数据做更新，使用类要好的多，在JavaScript中最好不要用本重构手法（不可变数据支持不好）



### 6.11 拆分阶段

将顺序执行的代码拆分



#### 编译器

词法分析 - token解析成语法树（AST） -  AST转换（AST transform/optimize）- 生成目标码

编译器的每个阶段又包含若干函数和类



如果一段代码中出现了上下几段，各自使用不同的一组数据和函数，这就是最明显的线索



## 7. 封装

类是为隐藏信息而生

除了类的的内部细节，使用隐藏委托关系隐藏类之间的关联关系通常也很有帮助，但过多隐藏也会导致冗余的中间接口

除了类和模块外，小的函数对于封装实现细节也有所裨益



### 7.1 封装记录

对象可以隐藏结构的细节

记录型结构（如对象子面量）只适合小范围使用

需要被序列化的数据（JSON）也值得封装



直接持有原始的记录会破坏封装的完整性

封装大型的数据结构时，更多关注更新操作

返回深拷贝的数据或者数据代理（proxy）以减少副作用

合理混用取值对象和新对象，即使用取值函数来封装数据的深层查找操作，但更新数据时则用对象来包装其结构，而非直接操作未经封装的数据



### 7.2 封装集合

封装程序中的所有可变数据

常见错误：只对集合的变量访问进行封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被修改，而封装它的类全然不知，无法介入



> 依赖别人的好习惯是不明智的

永远不直接返回集合的值

或者以某种形式限制集合的访问权，如返回只读代理



返回集合副本的方式可能带来性能问题

对源数据的修改会反映到代理上，但不会反映到副本上

封装集合的方案在同一个代码应保持一致



封装字段的引用并不一定会封装字段的内容



任何负责管理集合的类都应该总是返回数据副本



### 7.3 以对象取代基本类型

一旦对某个数据的操作不仅仅局限于打印时，就应该为它创建新类，这个操作对代码库往往有深远的影响



值对象提供equals方法



### 7.4 以查询取代临时变量

不适应于做快照用途的临时变量



### 7.5 提炼类

一个类应该是一个清晰的抽象

如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，就应该分离出类

开发后期，子类化只影响类的部分特征或某些特征需要以不同的方式子类化时应该分解原来的类



### 7.6 内联类

将两个类重新组织安排职责时常用

先内联成一个类再分离其职责会更简单



### 7.7 隐藏委托关系

一个好的模块化设计，封装是其最关键特征之一。封装意味着每个模块都应该尽可能少了解系统的其他部分



### 7.8 移除中间人

封装的代价：每当客户端要使用受托类的新特征时，你就必须在服务端添加一个简单委托函数，随着受托类的特征（功能）越来越多，服务类可能完全变成中间人。

不要过度使用迪米特法则

> 重构的意义在于：你永远不必说对不起--只要把出问题的地方修补好就行了



统一风格，委托阈值管理

代码环境自然会给出该使用哪种手法的线索，具备思考能力的程序员应能分辨出何种方法更佳



### 7.9 替换算法

使用函数库和小型函数



## 8. 搬移特性

### 8.1 搬移函数

模块化是优秀软件设计的核心所在，确保模块之间的联系易于查找，直观易懂



任何函数都需呀具备上下文环境才能存活，通常由模块所提供

对于面向对象的程序而言，类作为最主要的模块化手段，其本身就能充当函数的上下文



搬移函数最直接的一个动因是，它频繁引用其他上下文中的元素

搬移过程中，如果发现需要为整组函数创建一个新的上下文，此时就可以创建一个类



> 搭配委托使用



> ES2015提供的模块化可以用来控制函数的可见性

嵌套函数里的私有数据容易在函数之间共享增加代码的阅读和重构难度

### 8.2 搬移字段

数据结构是一个健壮程序的根基

糟糕的数据结构将招致许多无用代码，也会隐藏程序的真实意图



数据结构很难一次设计好

> 领域驱动设计

如果数据已经用类进行了封装，那么重构会更容易进行

将数据访问包装到方法中，是类所天然支持的一种封装手段

> 重构不能改变系统的可观测行为

### 8.3 搬移语句到函数

保持整体性

### 8.4 搬移语句到调用者

程序员的职责是设计出结构一致、抽象合宜的程序，而程序抽象能力的源泉正是来自函数

平衡好抽象的边界

函数边界发生偏移的一个征兆是，以往在多个地方共用的行为，如今在某些调用点面前表现出不同的行为

### 8.5 以函数调用取代内联代码

函数可以提升代码的表达力，消除重复

函数命名应该与内联代码的语境协调

善用库函数

### 8.6 移动语句

让存在关联的东西一起出现，可以使代码更容易理解

在第一次需要使用变量的地方再声明它，元素的声明点和使用点尽量相互靠近



对于没有副作用的代码，几乎可以随心所欲地编排顺序，这也是需要尽量编写无副作用代码的原因之一

遵循命令与查询分离，确定任何有返回值的函数都不存在副作用



要判断一次语句移动是否安全，就得真正理解代码的工作原理，以及运算符之间的组合方式



> 先改善测试代码再进行重构



### 8.7 拆分循环

拆分身兼多职的循环，确保修改代码只需要理解修改的代码块

对拆分的循环应用提炼函数

循环本身很少成为性能瓶颈



### 8.8 以管道取代循环

越来越对的语言提供集合管道



### 8.9 移除死代码

无用代码会带来很多额外的思维负担



## 9. 重新组织代码

讲一个值用于多个不同的用途是催生混乱和bug的温床

给变量起个好名字不容易但非常重要

消除多余的变量，以查询取代派生变量

引用和值的混淆经常会造成问题



### 9.1 拆分变量

分离“循环变量”和“结果收集变量”

如果变量承担多个责任，就应该被替换为多个变量

如果可能的话，将新变量声明为不可修改



### 9.2 字段改名

命名很重要，对字段的命名格外重要

现在已经不太有人画流程图了，但道理还是一样

数据结构是理解程序行为的关键

如果在重构过程中破坏了测试，说明需要改用更渐进的方式来重构



### 9.3 以查询取代派生变量

可变数据源是软件中最大的错误源头之一

计算常能更清晰地表达数据的含义，而且也避免了源数据修改时忘了更新派生变量的错误

单一数据源



面向对象编程：把一系列计算得出的属性包装在数据结构中

函数式编程：将一个数据结构变换为另一个数据结构

如果源数据会被修改，而你必须负责管理派生数据结构的整个生命周期，那么对象风格显然更好。但如果源数据不可变，或者派生数据用过即弃，那么两种风格都可行



### 9.4 将引用对象改为值对象

值对象和引用对象的主要差别在于如何更新内部对象的属性

值对象通常更容易理解，主要是因为不可变，值对象在分布式系统和并发系统尤为有用

如果需要共享对象则使用引用



提供一个基于值的相等性判断函数

> 大部分编程语言都提供了可覆写的相等性判断函数，通常还必须同时覆写生成散列码的函数[Java Object.equals() Object.hashCode()]
>
> 或者使用操作符重载（Ruby）



### 9.5 将值对象改为引用对象

共享关系

对于一个客观实体，只有一个代表它的对象



使用对象仓库

可以在第一次使用时创建或初始化创建全部对象



可以将仓库对象作为参数传递给构造函数以解耦



##  10. 简化条件逻辑

### 10.1 分解条件表达式

复杂的条件逻辑是最常导致复杂度上升的地点之一

大型函数本身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读

### 10.2 合并条件表达式

合并检查条件各不相同，最终行为却一致的条件表达式

将检查条件提炼成一个独立的函数对于厘清代码意义非常有用，因为它把描述“做什么”的语句换成了“为什么这么做”

### 10.3 以卫语句取代嵌套条件表达式

```js
if(isAlive) return aliveAmount()
```

如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为卫语句

单一出口规则，其实不是那么有用。保持代码清晰才是最关键的。

将条件表达式反转，从而实现以卫语句取代嵌套表达式

### 10.4 以多态取代条件表达式

复杂的条件逻辑是编程中最难理解的东西之一

类和多态能把逻辑拆分表述的更清晰



最明显的征兆时有好几个函数都有基于类型代码的switch语句

另一种情况是：有一个基础逻辑，在其上又有一些变体。可以把基础逻辑放进超类，然后把每种变体逻辑单独放进一个子类，其中的代码着重强调与基础逻辑的差异



多态时面向对象的关键特征之一，但也很容易被滥用

>  用工厂函数创建对象

> 在js中保留超类帮助阐释各个子类与问题域之间的关系

> 函数名中出现And字样是一个很不好的味道

引入一个函数以便子类覆写，是处理“基础与变体”的继承关系时的常见操作

### 10.5 引入特例

一个数据的使用者都在检查某个特殊的值，并且当这个特殊值出现时所做的处理也都相同时，应该使用特例

一个通常需要处理的值就是null，这个模式常被叫做“Null对象”模式，Null对象是特例的一种特例

> 特例可在函数中返回或在变换函数（enrichFunction）中生成

### 10.6 引入断言

断言失败白哦是程序员犯了错误

断言是一种很有价值的交流方式



断言放在setter上是一种典型的使用方式

真正引起错误的源头很可能很难发现

不要滥用断言，只用来检查必须为真的条件。滥用断言可能会造成代码重复，尤其是在处理条件逻辑时。

只用断言预防程序员的错误，断言是帮助我们追踪bug的最后一招



## 11. 重构API

模块和函数式软件的骨肉，而API则是将骨肉连接起来的关节

### 11.1 将查询函数和修改函数分离

好的API会把更新数据的函数与只是读取数据的函数清晰分开

任何有返回值的函数，都不应该有看得到（缓存不算）的副作用

### 11.2 函数参数化

合并逻辑相同的函数

### 11.3 移除标记参数

标记参数让函数调用变得难以理解，隐藏了函数调用的差异性

> 只有调用者直接传入的字面量值才是标记参数，而非程序中流动的数据

移除标记参数不仅使代码更整洁，并且能帮助开发工具更好的发挥作用

如果一个函数有多个标记参数，说明这个函数可能做得太多，应该考虑是否能用更简单的函数来组合出完整的逻辑



用一个布尔型字面量来判断应该运行哪个分支代码是典型的标记参数场景



### 11.4 保持对象完整

传递整个记录的方式能更好的应对变化

可以将重复的处理逻辑移入到完整对象中



从一个对象中抽取出几个值，单独对这几个值做某些逻辑操作，这是一种代码坏味道，通常标志着这段逻辑应该被搬移到对象中



### 11.5 以查询取代参数

函数的参数列表应该总结该函数的可变性

参数列表应该尽量避免重复，并且参数列表越短就越容易理解

当移除参数可能给函数体增加不必要的依赖关系--迫使函数访问某个程序元素时，可以不用这个方式

如果可以从一个参数推导出另一个参数，那么几乎没有任何理由要同时传递这两个参数



### 11.6 以参数取代查询

处理依赖关系，降低耦合度



如果一个函数用同样的参数调用总是给出同样的结果，我们就说这个函数具有引用透明性

把不具引用透明性的元素变成参数传入，函数就能重获引用透明性

引用透明性利于测试和理解



常见的模式：在负责逻辑处理的模块中只有纯函数，其外再包裹处理I/O和其他可变元素的逻辑代码



会增加函数调用者的复杂度，这是一个责任分配问题



### 11.7 移除设值函数

readonly

> 脚本创建对象：首先调用构造函数，再通过一些列设值函数调用，共同完成新对象的创建



### 11.8 以工厂函数取代构造函数

构造函数常有一些丑陋的局限性

- Java 中只能返回当前类的实例：无法根据环境参数返回子类实例或代理对象
- 名字固定
- 需要通过特殊操作符调用（一般是new）



### 11.9 以命令取代函数

命令对象提供更大的控制灵活性和更强的表达能力

命令对象还可以支持附加的操作，例如撤销操作

在不支持函数作为一等公民的编程语言中，通过命令对象可以给函数提供大部分相当于一等公民的能力

命令对象的灵活性是以复杂性作为代价的



在命令对象的构造函数中传入参数，而不是execute函数

多个命令类可以利用组合模式调度执行

js中可以考虑用嵌套函数代替命令对象



### 11.10 以函数取代命令

当函数不复杂时



## 12. 处理继承关系

继承机制十分实用，却也经常被误用

### 12.1 函数上移

避免重复函数很重要

对相似的子类方法使用函数参数化和函数上移

可以利用模版函数实现略有差异的细节

### 12.2 字段上移

通过观察函数调用发现可上移的字段

### 12.3 构造函数本体上移

构造函数对函数的调用次序有所限制

先（super）初始化共用的数据，再有各个子类完成额外的工作

对于复杂的过程，使用工厂函数

### 12.4 函数下移

下移只与子类有关的函数

### 12.5 字段下移

下移只与子类有关的字段

### 12.6 以子类取代类型码

类型码字段可实现为枚举、符号、字符串或者数字



继承： 1.可以用多态处理条件逻辑2.分离只对特定类型码有意义的字段

直接继承或者以对象取代基本类型作为类型码

> 让测试失败以确保修改的代码被执行

### 12.7 移除子类

子类存在着就有成本，所以如果子类的用处太少，就不值得存在了



instance运算符不是好味道

警惕在超类引用子类



### 12.8 提炼超类

很多技术专家认为继承必须预先仔细计划，应该根据“真实世界”的分类结构建立对象模型。但是很多时候。合理的继承关系是在程序演化的过程中才浮现出来的。

在继承和委托之间选择，把重复的行为收拢一处

### 12.9 折叠继承体系

合并与超类差别不大的子类

### 12.10 以委托取代子类

继承这张牌只能打一次。导致行为不同的原因可能有多种，但继承只能用于处理一个方向上的变化。

继承给类之间引入非常紧密的关系。在超类上做任何修改，都很可能破坏子类，必须充分理解子类如何从超类派生。



这两个问题用委托都能解决。对于不同的变化原因，可以委托给不同的类，委托是对象之间常规的关系。与继承相比，使用委托关系时接口更清晰、耦合更少



继承时一种很有价值的机制，大部分时候能达到效果，不会带来问题。

之所以强调组合优于继承，其实是对继承常被滥用的回应。



用状态模式或者策略模式取代子类，这两个模式在结构上是相同的，都是由宿主对象把责任委托给另一个继承体系。以委托取代子类并非总会需要建立一个继承体系来接受委托，不过建立一个状态或策略的继承体系经常都是有用的。



有些函数的组织方式完全是为了方便覆写特定类型的行为。

如果刻意不关注子类的存在，在修改超类时偶尔有可能会破坏子类。



委托更方便动态转换类型

委托类的构造函数通常包含反向引用



委托子类需要调用超类的同名函数时，有两种方法处理：

1. 把分发逻辑与计算逻辑拆开
2. 重新定义委托对象中的函数，使其成为基础函数的扩展

后者代码较少



委托增加了分发逻辑，双向引用，复杂度上升不少



显式类型检查几乎总是坏主意



在委托类中建立继承体系，新的继承体系范围更收拢了

直接调用委托对象，通过委托类的继承体系来分发



审慎地组合使用对象组合与类继承，优于单独使用其中任何一种



### 12.11 以委托取代超类

经典的误用继承的例子：让栈继承列表

列表类的所有操作都会出现在栈类的接口上，然而其中大部分操作对一个栈来说并不适用。

如果超类的一些函数对子类并不适用，就说明不应该通过继承来获取超类的功能

> 里氏替换：子类的所有实例都应该是超类的实例

类型与实例明不符实是常见而又经常不易察觉的建模错误（如车继承车模）



即使在子类继承是合理的建模方式，如果子类与超类之间的耦合过强，超类的变化也很容易破坏子类的功能。

以委托取代超类的缺点是，对于宿主类和委托类中原本一样的函数，必须在宿主类中挨个编写转发函数。好在转发函数虽然乏味，但是非常简单。



如果符合继承关系的语义条件（超类的所有方法都适用于子类，子类的所有实例都是超类的实例)，那么继承体系是一种简洁又高效的复用机制。

首先尽量使用继承，如果发现继承有问题，再使用以委托取代超类

